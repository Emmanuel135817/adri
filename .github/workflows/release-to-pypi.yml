name: Release to PyPI (TestPyPI ‚Üí Production)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag to release (e.g., Release.Minor.v0.3.0)'
        required: true
        type: string
      force_republish:
        description: 'Force republish even if version exists'
        required: false
        type: boolean
        default: false

env:
  PYTHON_VERSION: "3.11"

jobs:
  validate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      tag_name: ${{ steps.validate.outputs.tag_name }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}
      release_type: ${{ steps.validate.outputs.release_type }}
      validation_result: ${{ steps.validate.outputs.validation_result }}
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Check PyPI version status
      id: pypi-check
      run: |
        echo "üîç Checking PyPI version status..."
        cd scripts

        # Check current PyPI versions and sync status
        PYPI_STATUS=$(python pypi_manager.py --status --no-pypi 2>/dev/null || echo "fallback")

        if [[ "$PYPI_STATUS" != "fallback" ]]; then
          echo "‚úÖ PyPI integration available"
          echo "pypi_available=true" >> $GITHUB_OUTPUT

          # Extract current versions
          PYPI_VERSION=$(echo "$PYPI_STATUS" | grep -o '"production_pypi": "[^"]*"' | cut -d'"' -f4)
          JSON_VERSION=$(echo "$PYPI_STATUS" | grep -o '"version_json_production": "[^"]*"' | cut -d'"' -f4)
          NEEDS_SYNC=$(echo "$PYPI_STATUS" | grep -o '"needs_sync": [^,}]*' | cut -d':' -f2 | tr -d ' ')

          echo "üì¶ PyPI version: $PYPI_VERSION"
          echo "üìã VERSION.json: $JSON_VERSION"
          echo "üîÑ Needs sync: $NEEDS_SYNC"

          echo "pypi_version=$PYPI_VERSION" >> $GITHUB_OUTPUT
          echo "json_version=$JSON_VERSION" >> $GITHUB_OUTPUT
          echo "needs_sync=$NEEDS_SYNC" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è PyPI integration not available - using fallback mode"
          echo "pypi_available=false" >> $GITHUB_OUTPUT
        fi

    - name: Sync VERSION.json with PyPI
      if: steps.pypi-check.outputs.pypi_available == 'true' && steps.pypi-check.outputs.needs_sync == 'true'
      run: |
        echo "üîÑ Synchronizing VERSION.json with PyPI..."
        cd scripts
        python pypi_manager.py --sync
        echo "‚úÖ VERSION.json synchronized with PyPI reality"

    - name: Validate release tag and version
      id: validate
      run: |
        # Get the tag name from event or input
        if [ "${{ github.event_name }}" = "release" ]; then
          TAG_NAME="${{ github.event.release.tag_name }}"
        else
          TAG_NAME="${{ github.event.inputs.tag_name }}"
        fi

        echo "üîç Processing release tag: $TAG_NAME"

        # Handle candidate tags (from draft releases)
        if [[ "$TAG_NAME" == candidate-* ]]; then
          echo "üìã Converting candidate tag to proper release tag..."

          # Extract type and version from candidate tag
          # candidate-minor-v0.3.0 -> Release.Minor.v0.3.0
          # candidate-beta-minor-v0.3.0 -> Pre-release.Minor.v0.3.0-beta.1

          if [[ "$TAG_NAME" == candidate-beta-* ]]; then
            # Beta release: candidate-beta-minor-v0.3.0 -> Pre-release.Minor.v0.3.0-beta.1
            CHANGE_TYPE=$(echo "$TAG_NAME" | sed 's/candidate-beta-\([^-]*\)-v.*/\1/')
            VERSION_BASE=$(echo "$TAG_NAME" | sed 's/candidate-beta-[^-]*-v\(.*\)/\1/')
            PROPER_TAG="Pre-release.${CHANGE_TYPE^}.v${VERSION_BASE}-beta.1"
          else
            # Production release: candidate-minor-v0.3.0 -> Release.Minor.v0.3.0
            CHANGE_TYPE=$(echo "$TAG_NAME" | sed 's/candidate-\([^-]*\)-v.*/\1/')
            VERSION_BASE=$(echo "$TAG_NAME" | sed 's/candidate-[^-]*-v\(.*\)/\1/')
            PROPER_TAG="Release.${CHANGE_TYPE^}.v${VERSION_BASE}"
          fi

          echo "üîÑ Converted: $TAG_NAME -> $PROPER_TAG"
          TAG_NAME="$PROPER_TAG"
        fi

        echo "üîç Validating release tag: $TAG_NAME"

        # Run PyPI-enhanced version validation script and capture outputs
        cd scripts
        VALIDATION_OUTPUT=$(python validate_version.py "$TAG_NAME" 2>&1)
        VALIDATION_EXIT_CODE=$?

        # Check if validation failed
        if [ $VALIDATION_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Version validation failed!"
          echo "$VALIDATION_OUTPUT"
          exit $VALIDATION_EXIT_CODE
        fi

        # Extract outputs from validation script
        VERSION=$(echo "$VALIDATION_OUTPUT" | grep "^version=" | cut -d'=' -f2)
        IS_PRERELEASE=$(echo "$VALIDATION_OUTPUT" | grep "^is_prerelease=" | cut -d'=' -f2)
        RELEASE_TYPE=$(echo "$VALIDATION_OUTPUT" | grep "^release_type=" | cut -d'=' -f2)

        # Set GitHub Actions outputs
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

        echo "‚úÖ Version validation successful with PyPI-first approach!"
        echo "üè∑Ô∏è Tag: $TAG_NAME"
        echo "üì¶ Version: $VERSION"
        echo "üß™ Pre-release: $IS_PRERELEASE"
        echo "üîÑ Release Type: $RELEASE_TYPE"

  test:
    needs: validate-version
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Update version in files
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        echo "Updating version to: $VERSION"

        # Update pyproject.toml
        sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml

        # Update adri/version.py
        sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" adri/version.py

        # Verify updates
        echo "pyproject.toml version:"
        grep "^version = " pyproject.toml
        echo "adri/version.py version:"
        grep "__version__ = " adri/version.py

    - name: Run test suite (excluding performance tests)
      timeout-minutes: 5
      run: |
        pytest tests/ -v --cov=adri --cov-report=xml --cov-fail-under=90 \
          -m "not performance and not stress and not slow"
      env:
        ADRI_VERSION: ${{ needs.validate-version.outputs.version }}

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          coverage.xml
          htmlcov/

  build:
    needs: [validate-version, test]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Update version in files
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml
        sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" adri/version.py

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine

    - name: Build package
      run: |
        python -m build

    - name: Check package
      run: |
        twine check dist/*
        echo "üì¶ Built packages:"
        ls -la dist/

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

  publish-testpypi:
    needs: [validate-version, build]
    runs-on: ubuntu-latest
    environment: testpypi
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install twine
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Publish to TestPyPI
      run: |
        echo "üß™ Publishing to TestPyPI..."

        # Try to upload, but don't fail if version already exists
        if twine upload --repository testpypi dist/* --verbose 2>&1 | tee upload_output.log; then
          echo "‚úÖ Successfully published to TestPyPI"
        else
          echo "‚ö†Ô∏è Upload failed - checking if it's due to existing version..."

          # Check if the error is about file already existing
          if grep -q "File already exists" upload_output.log; then
            echo "‚úÖ Version already exists on TestPyPI - continuing with workflow"
          else
            echo "‚ùå Upload failed for unknown reason"
            cat upload_output.log
            exit 1
          fi
        fi
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.TESTPYPI }}

    - name: Notify TestPyPI Success
      run: |
        echo "‚úÖ Successfully published to TestPyPI"
        echo "üì¶ Package: https://test.pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/"

  smoke-test-testpypi:
    needs: [validate-version, publish-testpypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: TestPyPI Smoke Tests
      run: |
        echo "üß™ Running TestPyPI smoke tests..."
        VERSION="${{ needs.validate-version.outputs.version }}"

        # Wait for TestPyPI propagation
        echo "‚è≥ Waiting for TestPyPI propagation..."
        sleep 60

        # Create clean test environment
        cd /tmp
        python -m venv testpypi_env
        source testpypi_env/bin/activate

        # Install packaging for version normalization
        pip install packaging

        # Normalize version for PyPI (rc.1 -> b1, alpha.1 -> a1, etc.)
        NORMALIZED_VERSION=$(python -c "
        from packaging.version import Version
        v = Version('$VERSION')
        print(str(v))
        ")

        echo "üìã Original version: $VERSION"
        echo "üìã Normalized version: $NORMALIZED_VERSION"

        # Install from TestPyPI using normalized version
        echo "üì¶ Installing from TestPyPI..."
        pip install -i https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ adri==$NORMALIZED_VERSION

        # Run comprehensive tests
        echo "‚úÖ Running comprehensive tests..."
        python -c "
        import time
        import pandas as pd
        from adri import adri_protected
        import adri

        # Version check
        print(f'‚úÖ Version: {adri.__version__}')
        assert adri.__version__ == '$VERSION', f'Version mismatch: {adri.__version__} != $VERSION'

        # Basic functionality check
        @adri_protected()
        def test_function(data):
            return data.shape[0]

        df = pd.DataFrame({'test': range(100)})
        start = time.time()
        result = test_function(df)
        duration = time.time() - start

        print(f'‚úÖ Functionality check: {duration:.2f}s')
        assert duration < 10.0, f'Performance regression: {duration}s'
        assert result == 100, f'Result mismatch: {result} != 100'

        print('üéâ All TestPyPI smoke tests passed!')
        "

  publish-pypi:
    needs: [validate-version, smoke-test-testpypi]
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install twine
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Check if version exists (unless forced)
      if: ${{ !github.event.inputs.force_republish }}
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        echo "üîç Checking if version $VERSION already exists on PyPI..."

        # Try to get package info
        if pip index versions adri | grep -q "$VERSION"; then
          echo "‚ùå Version $VERSION already exists on PyPI"
          echo "Use force_republish option to override (not recommended)"
          exit 1
        else
          echo "‚úÖ Version $VERSION is available for publishing"
        fi

    - name: Publish to Production PyPI
      run: |
        echo "üöÄ Publishing to Production PyPI..."
        twine upload dist/* --verbose
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI }}

    - name: Notify Production Success
      run: |
        echo "‚úÖ Successfully published to Production PyPI"
        echo "üì¶ Package: https://pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/"

  smoke-test-pypi:
    needs: [validate-version, publish-pypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Production PyPI Smoke Tests
      run: |
        echo "üß™ Running Production PyPI smoke tests..."
        VERSION="${{ needs.validate-version.outputs.version }}"

        # Wait for PyPI propagation
        echo "‚è≥ Waiting for PyPI propagation..."
        sleep 60

        # Create clean test environment
        cd /tmp
        python -m venv production_env
        source production_env/bin/activate

        # Install packaging for version normalization
        pip install packaging

        # Normalize version for PyPI (rc.1 -> b1, alpha.1 -> a1, etc.)
        NORMALIZED_VERSION=$(python -c "
        from packaging.version import Version
        v = Version('$VERSION')
        print(str(v))
        ")

        echo "üìã Original version: $VERSION"
        echo "üìã Normalized version: $NORMALIZED_VERSION"

        # Install from production PyPI using normalized version
        echo "üì¶ Installing from Production PyPI..."
        pip install adri==$NORMALIZED_VERSION

        # Run comprehensive tests
        echo "‚úÖ Running comprehensive tests..."
        python -c "
        import time
        import pandas as pd
        from adri import adri_protected
        import adri

        # Version check
        print(f'‚úÖ Version: {adri.__version__}')
        assert adri.__version__ == '$VERSION', f'Version mismatch: {adri.__version__} != $VERSION'

        # Basic functionality check
        @adri_protected()
        def test_function(data):
            return data.shape[0]

        df = pd.DataFrame({'test': range(100)})
        start = time.time()
        result = test_function(df)
        duration = time.time() - start

        print(f'‚úÖ Functionality check: {duration:.2f}s')
        assert duration < 10.0, f'Performance regression: {duration}s'
        assert result == 100, f'Result mismatch: {result} != 100'

        print('üéâ All production smoke tests passed!')
        "

  finalize-release:
    needs: [validate-version, smoke-test-pypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Update release with success status
      if: github.event_name == 'release'
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"

        # Update release notes with deployment info
        gh release edit $TAG_NAME \
          --notes "üéâ **Release $TAG_NAME Successfully Deployed**

        ## ‚úÖ **Deployment Status**
        - ‚úÖ Tests passed on GitHub Actions
        - ‚úÖ Package validated on TestPyPI
        - ‚úÖ Package published to Production PyPI
        - ‚úÖ Smoke tests passed on both platforms

        ## üì¶ **Installation**
        \`\`\`bash
        pip install adri==$VERSION
        \`\`\`

        ## üîó **Links**
        - [PyPI Package](https://pypi.org/project/adri/$VERSION/)
        - [TestPyPI Package](https://test.pypi.org/project/adri/$VERSION/)
        - [Documentation](https://github.com/ThinkEvolveSolve/adri-validator/blob/main/README.md)
        - [Changelog](https://github.com/ThinkEvolveSolve/adri-validator/blob/main/CHANGELOG.md)

        ## üöÄ **Usage**
        \`\`\`python
        from adri import adri_protected

        @adri_protected()
        def your_ai_function(data):
            # Your AI/ML code here
            return processed_data
        \`\`\`"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Slack Success Notification
      if: success()
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"

        echo "üéâ Release $TAG_NAME completed successfully!"
        echo "üì¶ Package available at: https://pypi.org/project/adri/$VERSION/"
        echo "üè∑Ô∏è GitHub release: https://github.com/ThinkEvolveSolve/adri-validator/releases/tag/$TAG_NAME"

        # Send Slack success notification
        if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
          echo "üì¢ Sending Slack success notification..."

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"good\",
                \"title\": \"üéâ ADRI Release $TAG_NAME Successfully Deployed!\",
                \"fields\": [
                  {\"title\": \"Version\", \"value\": \"$VERSION\", \"short\": true},
                  {\"title\": \"Type\", \"value\": \"${{ needs.validate-version.outputs.release_type }}\", \"short\": true},
                  {\"title\": \"PyPI Package\", \"value\": \"https://pypi.org/project/adri/$VERSION/\", \"short\": false}
                ],
                \"actions\": [
                  {
                    \"type\": \"button\",
                    \"text\": \"View on PyPI\",
                    \"url\": \"https://pypi.org/project/adri/$VERSION/\"
                  },
                  {
                    \"type\": \"button\",
                    \"text\": \"View Release\",
                    \"url\": \"https://github.com/${{ github.repository }}/releases/tag/$TAG_NAME\"
                  }
                ],
                \"footer\": \"ADRI Release System\",
                \"ts\": $(date +%s)
              }]
            }" \
            "${{ secrets.SLACK_WEBHOOK_URL }}" || echo "‚ö†Ô∏è Failed to send Slack notification"
        else
          echo "‚ö†Ô∏è SLACK_WEBHOOK_URL not configured - skipping notification"
        fi

  # Failure recovery job with automated rollback
  cleanup-on-failure:
    if: failure()
    needs: [validate-version, test, build, publish-testpypi, smoke-test-testpypi, publish-pypi, smoke-test-pypi, finalize-release]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Determine failure stage
      id: failure-stage
      run: |
        if [[ "${{ needs.test.result }}" == "failure" ]]; then
          echo "stage=test" >> $GITHUB_OUTPUT
          echo "message=Test suite failed" >> $GITHUB_OUTPUT
          echo "can_rollback=true" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.build.result }}" == "failure" ]]; then
          echo "stage=build" >> $GITHUB_OUTPUT
          echo "message=Package build failed" >> $GITHUB_OUTPUT
          echo "can_rollback=true" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.publish-testpypi.result }}" == "failure" ]]; then
          echo "stage=testpypi" >> $GITHUB_OUTPUT
          echo "message=TestPyPI publication failed" >> $GITHUB_OUTPUT
          echo "can_rollback=true" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.smoke-test-testpypi.result }}" == "failure" ]]; then
          echo "stage=testpypi-smoke" >> $GITHUB_OUTPUT
          echo "message=TestPyPI smoke tests failed" >> $GITHUB_OUTPUT
          echo "can_rollback=true" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.publish-pypi.result }}" == "failure" ]]; then
          echo "stage=pypi" >> $GITHUB_OUTPUT
          echo "message=Production PyPI publication failed" >> $GITHUB_OUTPUT
          echo "can_rollback=false" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.smoke-test-pypi.result }}" == "failure" ]]; then
          echo "stage=pypi-smoke" >> $GITHUB_OUTPUT
          echo "message=Production PyPI smoke tests failed" >> $GITHUB_OUTPUT
          echo "can_rollback=false" >> $GITHUB_OUTPUT
        else
          echo "stage=unknown" >> $GITHUB_OUTPUT
          echo "message=Unknown failure" >> $GITHUB_OUTPUT
          echo "can_rollback=true" >> $GITHUB_OUTPUT
        fi

    - name: Trigger automated rollback (pre-PyPI failures)
      if: steps.failure-stage.outputs.can_rollback == 'true'
      run: |
        echo "üîÑ Triggering automated rollback..."
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"

        # Use GitHub CLI to trigger rollback workflow
        gh workflow run rollback-release.yml \
          --field tag_name="$TAG_NAME" \
          --field rollback_reason="Automated rollback due to $FAILURE_MESSAGE in $FAILURE_STAGE stage" \
          --field failure_stage="$FAILURE_STAGE" \
          --field force_rollback="false"

        echo "‚úÖ Rollback workflow triggered"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Mark Release as Failed (manual intervention required)
      if: steps.failure-stage.outputs.can_rollback == 'false' && github.event_name == 'release'
      run: |
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"

        echo "üö® Marking release as failed (manual intervention required)..."

        # Convert release to draft and update with failure info
        gh release edit $TAG_NAME \
          --draft \
          --title "üö® FAILED: Release $TAG_NAME (Manual Intervention Required)" \
          --notes "‚ùå **Release Failed During Deployment - MANUAL INTERVENTION REQUIRED**

        ## üö® **Critical Failure Details**
        - **Stage**: $FAILURE_STAGE
        - **Message**: $FAILURE_MESSAGE
        - **Workflow**: [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - **Time**: $(date -u)

        ## ‚ö†Ô∏è **IMPORTANT: PyPI Publication Status**
        This failure occurred after potential PyPI publication. **Manual intervention is required.**

        ### üîç **Immediate Actions Required:**
        1. **Check PyPI**: Verify if package was published to https://pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/
        2. **If Published**: Consider yanking the package if it's broken
        3. **If Not Published**: Safe to retry after fixes

        ### üîß **Manual Rollback (if needed):**
        \`\`\`bash
        # If package was published and is broken, yank it:
        twine yank adri ${{ needs.validate-version.outputs.version }} --reason '$FAILURE_MESSAGE'
        \`\`\`

        ### üîÑ **To Retry:**
        1. **Fix the issues** identified in the workflow logs
        2. **If yanked**: Increment version number for new release
        3. **If not published**: Can retry with same version

        ## üìã **Cleanup Status**
        - ‚úÖ Release marked as draft
        - ‚ö†Ô∏è Git tag preserved (check PyPI status before deleting)
        - ‚ö†Ô∏è Manual PyPI cleanup may be required

        ## üîó **Useful Links**
        - [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - [PyPI Package](https://pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/)
        - [Manual Rollback Workflow](https://github.com/${{ github.repository }}/actions/workflows/rollback-release.yml)"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Mark Release as Failed (automated rollback completed)
      if: steps.failure-stage.outputs.can_rollback == 'true' && github.event_name == 'release'
      run: |
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"

        echo "üö® Updating release with automated rollback completion..."

        # Update release with rollback completion info
        gh release edit $TAG_NAME \
          --draft \
          --title "üîÑ ROLLED BACK: Release $TAG_NAME" \
          --notes "üîÑ **Release Automatically Rolled Back**

        ## üö® **Failure Details**
        - **Stage**: $FAILURE_STAGE
        - **Message**: $FAILURE_MESSAGE
        - **Workflow**: [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - **Time**: $(date -u)

        ## ‚úÖ **Automated Rollback Completed**
        - ‚úÖ Git tags cleaned up
        - ‚úÖ Draft releases removed
        - ‚úÖ No PyPI publication occurred
        - ‚úÖ Clean state restored

        ## üîß **To Retry**
        1. **Fix the issues** identified in the workflow logs
        2. **Push fixes** to the repository
        3. **Run prepare-releases workflow** to create new drafts
        4. **Publish new draft** to trigger release again
        5. **Same version number** can be reused

        ## üìã **Next Steps**
        1. Review workflow logs to identify root cause
        2. Implement fixes for the identified issues
        3. Test fixes locally before retrying release
        4. Monitor the retry release closely

        ## üîó **Useful Links**
        - [Failed Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - [Rollback Workflow](https://github.com/${{ github.repository }}/actions/workflows/rollback-release.yml)
        - [Repository](https://github.com/${{ github.repository }})
        - [Issues](https://github.com/${{ github.repository }}/issues)" 2>/dev/null || echo "‚ö†Ô∏è Could not update release (may have been deleted by rollback)"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Enhanced failure notification
      run: |
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"
        CAN_ROLLBACK="${{ steps.failure-stage.outputs.can_rollback }}"

        echo "üö® Release $TAG_NAME failed at stage: $FAILURE_STAGE"
        echo "üí¨ Message: $FAILURE_MESSAGE"
        echo "üîÑ Automated rollback: $CAN_ROLLBACK"
        echo "üîó Workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

        if [[ "$CAN_ROLLBACK" == "true" ]]; then
          echo "‚úÖ Automated rollback completed - safe to retry"
        else
          echo "‚ö†Ô∏è Manual intervention required - check PyPI status"
        fi

        # Send Slack failure notification
        if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
          echo "üì¢ Sending Slack failure notification..."

          ROLLBACK_STATUS=""
          if [[ "$CAN_ROLLBACK" == "true" ]]; then
            ROLLBACK_STATUS="‚úÖ Automated rollback completed"
            COLOR="warning"
            URGENCY="‚ö†Ô∏è Release Failed - Rollback Completed"
          else
            ROLLBACK_STATUS="üö® Manual intervention required"
            COLOR="danger"
            URGENCY="üö® URGENT: Release Failed - Manual Action Required"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$URGENCY: ADRI Release $TAG_NAME\",
                \"fields\": [
                  {\"title\": \"Failed Stage\", \"value\": \"$FAILURE_STAGE\", \"short\": true},
                  {\"title\": \"Status\", \"value\": \"$ROLLBACK_STATUS\", \"short\": true},
                  {\"title\": \"Error Message\", \"value\": \"$FAILURE_MESSAGE\", \"short\": false},
                  {\"title\": \"Next Steps\", \"value\": \"$(if [[ \"$CAN_ROLLBACK\" == \"true\" ]]; then echo \"Fix issues and retry release\"; else echo \"Check PyPI status and manual cleanup\"; fi)\", \"short\": false}
                ],
                \"actions\": [{
                  \"type\": \"button\",
                  \"text\": \"View Workflow\",
                  \"url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                }],
                \"footer\": \"ADRI Release System\",
                \"ts\": $(date +%s)
              }]
            }" \
            "${{ secrets.SLACK_WEBHOOK_URL }}" || echo "‚ö†Ô∏è Failed to send Slack notification"
        else
          echo "‚ö†Ô∏è SLACK_WEBHOOK_URL not configured - skipping notification"
        fi

    - name: Cleanup Summary
      run: |
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        CAN_ROLLBACK="${{ steps.failure-stage.outputs.can_rollback }}"

        echo "üßπ Cleanup completed for failed release"
        echo "üìù Summary:"
        echo "   - Failure stage: $FAILURE_STAGE"

        if [[ "$CAN_ROLLBACK" == "true" ]]; then
          echo "   - ‚úÖ Automated rollback executed"
          echo "   - ‚úÖ Git tags cleaned up"
          echo "   - ‚úÖ Draft releases removed"
          echo "   - ‚úÖ Safe to retry with same version"
        else
          echo "   - ‚ö†Ô∏è Manual intervention required"
          echo "   - ‚ö†Ô∏è Check PyPI publication status"
          echo "   - ‚ö†Ô∏è May need to yank package if published"
        fi

        echo "   - üìã Release updated with failure details"
        echo "   - üîî Team notified"
        echo "   - üìä Workflow logs available for debugging"
